# 4. 트랜잭션과 잠금
## 서론
- 트랜잭션이란?
    - 트랜잭션은 작업의 완전성을 보장해 주는 것이다. 
    - 즉 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구한다.
    
- 잠금이란?
    - 잠금은 동시성을 제어하기 위한 기능이며, 정합성을 보장하는 기능인 트랜잭션과는 다르다.
    
## 4.1 트랜잭션
### 4.1.1 MySQL에서의 트랜잭션
- 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 (Commit)
- 아무것도 적용되지 않아야함을 보장해주는 것이다. (RollBack)
- InnoDB는 쿼리 중 일부라도 오류가 발생하면 전체를 원상태로 만들어 준다.

### 4.1.2 주의사항
- 트랜잭션은 최소한의 코드에만 적용하는 것이 좋다.

## 4.2 MySQL 엔진의 잠금
### 서론
- MySQL에서 사용되는잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눠볼 수 있다.
- MySQL 엔진은 MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분으로 이해하면 된다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만, 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않는다.
- MySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락 말고도 사용자의 필요에 맞게 사용할 수 있는 유저 락과 테이블 명에 대한 잠금을 위한 네임 락 제공

### 4.2.1 글로벌 락
- 글로벌락(GLOBAL LOCK)은 'FLUSH TABLES WITH READ LOCK" 명령으로만획득할수 있으며， MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득 -> 다른 세션에서 SELECT 를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때까지 해당 문장이 대기 상태
- 글로벌 락이 영향을 미치는 범위 -> MySQL 서버 전체
- 여러 데이터베이스에 존재하는 MyISAM, MEMORY 테이블에 대하여 mysqldump로 일관된 백업을 받아야할 때는 글로벌 락을 사용해야함

### 4.2.2 테이블 락
- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 특정 테이블 락을 획득할 수 있음
- 명시적 
    - "LOCK TABLE table_name [READ | WRITE]" 명령으로 특정 테이블 락 획득 가능
    - "UNLOCK TABLES" 명령으로 잠금을 반납(해제) 가능
    - MyISAM 뿐 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정 가능
    - 명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 거의 사용할 필요가 없다.
    - 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문
- 묵시적
    - MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
    - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태
    - 쿼리가 실행되는 동안 자동적으로 획득, 쿼리 완료 후 자동 해제
    - InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공 
    - 즉, 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지 않음
    - 더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 댑분의 데이터 변경(DML) 쿼리에서는 무시되고 스키마 변경 쿼리 (DDL) 경우에만 영향을 미침

### 4.2.3 유저 락
- 유저락은 단순히 사용자가지정한문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.
- 많은 레코드를 한 번에 변경하는 트랜잭션의 경우에 유용하다.
- 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행해서 데드락을 해결할 수 있다.

### 4.2.4 네임 락
- 데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름을 변겨하는 경우 획득하는 잠금
- 테이블 이름을 변경하는 경우 자동으로 획득되는 잠금

## 4.3 MyISAM과 Memory 스토리지 엔진의 잠금
### 서론
- MyISAM이나 Memory 스토리지 엔진은 자체적인 잠금을 가지지 않고 MySQL 엔진에서 제공하는 테이블 락을 그대로 사용
- 그리고 MyISAM이나 Memory 스토리지 엔진에서는 쿼리 단위로 필요한 잠금을 한꺼번에 모두 요청해서 획득하기 때문에 데드락이 발생할 수 없다.

## 4.4 InnoDB 스토리지 엔진의 잠금
### 서론
- InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탐재하고 있음
- 그렇기 때문에 MyISAM과 Memory 보다 뛰어난 동시성 처리가 가능 -> 이유 ?

### 4.4.1 InnoDB의 잠금 방식
- 비관적 잠금
    - 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식
    - 다른 트랙잭션이 선점하지 못하도록 먼저 락을 하는 방식이다.
    - InnoDB는 비관적 잠금 방식을 채택하고 있다.
- 낙관적 잠금
    - 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성이 희박할 것이라는 가정하에 동작하는 잠금이다.
    - 그래서 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있는지 확인하고 문제가 있다면 ROLLBACK 처리하는 방식이다.
  
### 4.4.2 InnoDB의 잠금 종류
#### 레코드 락
- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공
- 또한 사용 DBMS 와는 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP)락이 존재
- InnoDB 스토리지 엔진은 상용 DBMS 와는 다르게 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
- 만약 인덱스가 하나도 없는 테이블이라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정

#### 갭락
- 갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미
- 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 INSERT되는 것을 제어
- 자체적으로 사용되지는 않고 넥스트 키 락의 일부로 사용

#### 넥스트 키 락
- 레코드락과 갭 락을 합친 개념
- 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때, 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장 

#### 자동 증가 락
- InnoDB 스토리지 엔진에서는 내부적으로 AUTO_INCREMENT 락이라고 하는 테이블 수준의 잠금을 사용

### 4.4.3 인덱스와 잠금
- 테이블에 인덱스가 하나도 없다면, 테이블을 풀 스캔하면서 UPDATE 작업을 하게 된다.
- 테이블에 데이터가 10만 건이 있다면, 10만 건의 모든 레코드를 잠그게 된다.

### 4.4.4 트랜잭션 격리 수준과 잠금
- MySQL 5.1 버전 이상 부터는 바이너리 로그가 활성화되면 최소 REPEATABLE-READ 이상의 격리 수준을 사용하도록 강제
- 5.1 이상을 사용하는 경우 갭 락이나 넥스트 키락 제거 방법
    - 1.
        - 바이너리 로그를 비활성화
        - 트랜잭션 격리 수준을 READ-COMMITED 설정
    - 2.
        - 레코드 기반의 바이너리 로그 사용
        - innodb_locks_unsafe_for_binlog=1
        - 트랜잭션 격리 수준을 READ-COMMITED로 설정
  
### 4.4.5 레코드 수준의 잠금 확인 및 해제
- 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 그 레코드가 자주 사용되지 않는다면 오랜 시간 동안 잠겨진 상태로 남아 있어도 잘 발견되지 않는다.

#### MySQL 5.1 이상의 잠금 확인 및 해제
- MySQL 5.1 부터는 INFORMATION_SCHEMA 라는 DB에 INNODB_TRX 라는 테이블과 INNODB_LOCKS, INNODB_LOCK_WAITS 테이블 존재
- 잠금이나 대기가 발생할 경우 InnoDB 스토리지 엔진에서 관련 정보를 계속 이 테이블로 업데이트
- 따라서 SELECT 해서 확인 가능


## 4.5 MySQL 격리 수준
### 서론
- 격리 수준 종류
    - READ UNCOMMITTED
    - READ COMMITTED -> DIRTY READ -> 일반적인 디비에서는 잘 사용하지 않음
    - REPEATABLE READ
    - SERIALIZABLE -> 동시성이 중요한 데이터베이스에서 거의 사용되지 않음
- 4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리 정도가 높아짐
- 동시성도 떨어짐, 그러나 성능은 사실 SERIALIZABLE 격리 수준이 아니라면 크게 성능 개선이나 저하가 발셍하지는 않음
